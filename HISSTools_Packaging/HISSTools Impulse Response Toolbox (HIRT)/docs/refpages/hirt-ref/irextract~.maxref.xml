<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been (sort of) automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="irextract~" module="hirt">

	<digest>
		Process recorded measurements from the irmeasure~ object
	</digest>

	<description>
		The <o>irextract~</o> object corresponds to the post processing chain section of the <o>irmeasure~</o> object. Recordings taken from <o>irmeasure~</o> using the <m>extract</m> message can be later processed by <o>irextract~</o> to retrieve the IRs. This allows tweaking of deconvolution parameters to suit the application. In order for this to work correctly you must supply <o>irextract~</o> with exactly the same measurement parameters as the <o>irmeasure~</o> object. The object processes buffers that represent one measured input channel. It is necessary to specify how many output channels were measured, so as to match the recording correctly.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">Alex Harker</metadata>
		<metadata name="tag">HIRT</metadata>
		<metadata name="tag">HIRT Objects</metadata>
		<metadata name="tag">HIRT Impulse Response</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Instructions to <o>irextract~</o>
			</digest>
			<description>
				<m>sweep</m>, <m>mls</m>, <m>white</m>, <m>brown</m>, <m>pink</m>, <m>clear</m>, <m>getir</m>, <m>dump</m>
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				<m>Bang</m> on completion of called process
			</digest>
			<description>
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="NONE" optional="0" type="none">
			<digest>
				No arguments for <o>irextract~</o>
			</digest>
			<description>
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="brown">
			<arg name="buffer_name" optional="0" type="symbol" />
			<arg name="length" optional="1" type="int" />
			<arg name="fade_in" optional="1" type="int/float" />
			<arg name="fade_out" optional="1" type="int/float" />
			<arg name="num_out_chans" optional="0" type="int" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Process a brown-noise recording
			</digest>
			<description>
				Syntax: <b>brown <m>&lt;symbol: buffer_name&gt;</m> <m>[&lt;int: length&gt;]</m> <m>[&lt;int/float: fade_in&gt;]</m> <m>[&lt;int/float: fade_out&gt;]</m> <m>&lt;int: num_out_chans&gt;</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				Processes a brown-noise recording from <o>irmeasure~</o>. (Other avalaible colours are: <m>white</m> &amp; <m>pink</m>). <br />
				<m>brown</m> defaults: [name] / 10000ms / 10ms / 10ms / [channels] / 5000ms <br />
			</description>
		</method>
		<method name="clear">
			<arglist />
			<digest>
				Clear all allocated memory
			</digest>
			<description>
			</description>
		</method>
		<method name="dump">
			<arg name="output_buffer_name" optional="0" type="symbol" />
			<digest>
				Place the internal processed ouput for one input channel into a named <o>buffer~</o>
			</digest>
			<description>
				Syntax: <b>dump <m>&lt;symbol: output_buffer_name&gt;</m> </b><br />				<br />
				<b>!! The <m>dump</m> message can only be used AFTER processing <o>irextract~</o> !!</b> <br />
				<br />
				The <m>dump</m> message allows the processsed recording (containing all IRs for a given input channel, including nonlinear components where relevant) for one of the measurement input channels to be dumped to a named <o>buffer~</o>. <br />
			</description>
		</method>
		<method name="getir">
			<arg name="buffer_name" optional="0" type="symbol" />
			<arg name="out_chan" optional="1" type="int" />
			<arg name="harmonic" optional="1" type="int" />
			<digest>
				Retrieve IR
			</digest>
			<description>
				Syntax: <b>getir <m>&lt;symbol: buffer_name&gt;</m> <m>[&lt;int: out_chan&gt;]</m> <m>[&lt;int: harmonic&gt;]</m> </b><br />				<br />
				<b>!! IRs must be retrieved to a <o>buffer~</o> with the <m>getir</m> message AFTER processing !!</b> <br />
				<br />
				<m>getir</m> defaults: [name] / 1 / 1. N.B. the harmonics arg (arg 3) is only available if using a <m>sweep</m> measurement and must be an <m>integer</m> <b>&gt;= 1</b>. <br />
			</description>
		</method>
		<method name="mls">
			<arg name="buffer_name" optional="0" type="symbol" />
			<arg name="order" optional="1" type="int" />
			<arg name="num_out_chans" optional="0" type="int" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Process an MLS recording
			</digest>
			<description>
				Syntax: <b>mls <m>&lt;symbol: buffer_name&gt;</m> <m>[&lt;int: order&gt;]</m> <m>&lt;int: num_out_chans&gt;</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				Processes an MLS recording from <o>irmeasure~</o>. <br />
				<m>mls</m> defaults: [name] / 18 / [channels] / 5000ms <br />
			</description>
		</method>
		<method name="pink">
			<arg name="buffer_name" optional="0" type="symbol" />
			<arg name="length" optional="1" type="int" />
			<arg name="fade_in" optional="1" type="int/float" />
			<arg name="fade_out" optional="1" type="int/float" />
			<arg name="num_out_chans" optional="0" type="int" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Process a pink-noise recording
			</digest>
			<description>
				Syntax: <b>pink <m>&lt;symbol: buffer_name&gt;</m> <m>[&lt;int: length&gt;]</m> <m>[&lt;int/float: fade_in&gt;]</m> <m>[&lt;int/float: fade_out&gt;]</m> <m>&lt;int: num_out_chans&gt;</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				Processes a pink-noise recording from <o>irmeasure~</o>. (Other avalaible colours are: <m>white</m> &amp; <m>brown</m>). <br />
				<m>pink</m> defaults: [name] / 10000ms / 10ms / 10ms / [channels] / 5000ms <br />
			</description>
		</method>
		<method name="sweep">
			<arg name="buffer_name" optional="0" type="symbol" />
			<arg name="low_freq" optional="1" type="int/float" />
			<arg name="high_freq" optional="1" type="int/float" />
			<arg name="length" optional="1" type="int" />
			<arg name="fade_in" optional="1" type="int/float" />
			<arg name="fade_out" optional="1" type="int/float" />
			<arg name="num_out_chans" optional="0" type="int" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Process a sweep recording
			</digest>
			<description>
				Syntax: <b>sweep <m>&lt;symbol: buffer_name&gt;</m> <m>[&lt;int/float: low_freq&gt;]</m> <m>[&lt;int/float: high_freq&gt;]</m> <m>[&lt;int: length&gt;]</m> <m>[&lt;int/float: fade_in&gt;]</m> <m>[&lt;int/float: fade_out&gt;]</m> <m>&lt;int: num_out_chans&gt;</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				Processes a sweep recording from <o>irmeasure~</o>. The <m>ampcurve</m> attribute must also match that used for the recording. See the <m>ampcurve</m> description for details. <br />
				<m>sweep</m> defaults: [name]  / 20Hz / nyquist / 30000ms / 50ms / 10ms / [channels] / 5000ms <br />
			</description>
		</method>
		<method name="white">
			<arg name="buffer_name" optional="0" type="symbol" />
			<arg name="length" optional="1" type="int" />
			<arg name="fade_in" optional="1" type="int/float" />
			<arg name="fade_out" optional="1" type="int/float" />
			<arg name="num_out_chans" optional="0" type="int" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Process a white-noise recording
			</digest>
			<description>
				Syntax: <b>white <m>&lt;symbol: buffer_name&gt;</m> <m>[&lt;int: length&gt;]</m> <m>[&lt;int/float: fade_in&gt;]</m> <m>[&lt;int/float: fade_out&gt;]</m> <m>&lt;int: num_out_chans&gt;</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				Processes a white-noise recording from <o>irmeasure~</o>. (Other avalaible colours are: <m>brown</m> &amp; <m>pink</m>). <br />
				<m>white</m> defaults: [name] / 10000ms / 10ms / 10ms / [channels] / 5000ms <br />
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="amp" get="1" set="1" type="float" size="1">
			<digest>
				Signal Maximum Amplitude (dB)
			</digest>
			<description>
				Sets the maximum ampltiude of the generated signal in <b>dB</b>.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Signal Maximum Amplitude (dB)" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="ampcurve" get="1" set="1" type="atom_array" size="3">
			<digest>
				Sweep Amplitude Curve Specification
			</digest>
			<description>
				Instead of producing sweeps with a flat amplitude response the ampltiude can be varied with frequency, so as to best suit the measured system (for instance using lower ampltudes at low and high frequencies, thus avoiding distortion of the measurement speaker). <br />
				When blank, sweeps will be flat. Otherwise you should specify the ampitude response using frequency (<b>Hz</b>) &amp; amplitude (<b>dB</b>) pairs. <br />
				Example: <b><m>ampcurve</m> 10 -20 40 0 16000 0 19000 -25</b> <br />
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Sweep Amplitude Curve Specification" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="bandlimit" get="1" set="1" type="int" size="1">
			<digest>
				Bandlimit Sweep Measurements
			</digest>
			<description>
				When <m>bandlimit</m> is <b>on</b>, measurements taken using the <m>sweep</m> signal are automatically bandlimited to the range of the sweep (the deconvolution filter is automatically generated, bypassing the deconvolution filter settings). <br />
				The fade times determine the steepness of the filter slope at low and high frequencies (shorter fade in times give a steeper <b>LF</b> rolloff, shorter fade out times give a steeper <b>HF</b> rolloff). This is the most appropriate setting for acoustic measurements. <br />
				When <b>off</b>, the deconvolution filter settings are used for sweep measurements. This may be more appropriate for measuring within a digital system, or when hand tuning of settings is desirable. <br />
				This attribute does not affect measruements using the <m>mls</m> or <m>coloured noise</m> signals.
				<br />
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Bandlimit Sweep Measurements" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="deconvfilter" get="1" set="1" type="atom_array" size="0">
			<digest>
				Deconvolution Filter Specification
			</digest>
			<description>
				Regardless of the deconvolution mode (<m>deconvmode</m>) it is necessary to set a specification for how to control the deconvolution over the frequency range. The <m>deconvfilter</m> specification sets a frequency curve to apply to the relevant mode. <br />
				You may either specify a static value in <b>dB</b>, or a <m>list</m> of <b>freq/dB</b> values to vary the specification with frequency. For <m>regularisation</m> this sets the constant value to add to the divisor. <br />
				For <m>clipping</m> it sets the minimum values allowed for the division. For <m>filter</m> it sets the shape of the filter. <br />
				Typically, for standard usage, very low or high frequencies are liable to blowup through overcorrection or numeric error. Thus higher values for <m>regularisation</m> and <m>clipping</m> are appropraite at low/high frequencies. <br />
				The <m>filter</m> mode works in the inverse, and lower values (less gain) are generally more appropriate for extremes of frequency. <br />
				Additionally you may specify the name of a <o>buffer~</o> as the filter specification in which case the power spectrum of the <o>buffer~</o> is used to determine the specification for <m>regularisation</m> and <m>clipping</m> modes, <br />
				and the <o>buffer~</o> is applied directly as a convolution filter in <m>filter</m> mode (ignoring the <m>deconvphase</m> attribute setting in this case). <br />
				This allows a high degree of control of the process for special applications or custom solutions. <br />
				<b>units: symbol &amp; list</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Specification" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvmode" get="1" set="1" type="int" size="1">
			<digest>
				Deconvolution Filter Mode
			</digest>
			<description>
				Deconvolution must be controlled so as to prevent filter blow-up or excessive time-aliasing. The control is equivalent to filtering the result of a staightforward complex division in the frequency domain (hence the term filter). The three modes are: <br />
				<b>0</b>, Regularisation: Regularise the division by adding a constant to the division <br />
				<b>1</b>, Clipping: Clip the denominator in the division <br />
				<b>2</b>, Specify the filter explicitly <br />
				<b>units: int, default: 0, range: 0..2</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Mode" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="deconvphase" get="1" set="1" type="atom" size="1">
			<digest>
				Deconvolution Filter Phase
			</digest>
			<description>
				The method by which deconvolution is controlled acts as a FIR filter on result of the 'true deconvolution'. This filter will produce time smearing of the result. This can result in pre or post ring in the resultant IR. <br />
				By controlling the phase of the implicit filter we can control this ring. <br />
				The default is <b>minimum</b> phase which post-rings only. The phase may either be specified as a float value between <b>0</b> and <b>1</b> (where <b>0</b> is <b>minimum</b> phase, <b>0.5</b> is <b>linear</b> phase and <b>1</b> is <b>maximum</b> phase), <br />
				or using any of the following symbols: <br />
				<b>min</b> / <b>minimum</b>: Minimum Phase <br />
				<b>lin</b> / <b>linear</b>: Linear Phase <br />
				<b>max</b> / <b>maximum</b>: Maximum Phase <br />
				<b>units: float or symbol, default: 0 / minimum, range: 0..1 or min/lin/max</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Phase" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvrange" get="1" set="1" type="atom_array" size="0">
			<digest>
				Deconvolution Filter Range
			</digest>
			<description>
				When <m>deconvmode</m> is <m>clipping</m> the denominator of the divsion can be clipped to both minimum values (controlling peaks in the output) and also maximum values (controlling dips in the output). <br />
				The <m>deconvrange</m> attibute sets the maximum values in relation to the filter specification. Similarly to the deconvolution filter specification (<m>deconvfilter</m>),
				you may either specify a single value in <b>dB</b> or use a list of <b>freq/dB</b> pairs to vary the range with frequency. <br />
				<b>units: symbol &amp; list</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Range" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="invamp" get="1" set="1" type="int" size="1">
			<digest>
				Invert Amplitude
			</digest>
			<description>
				When <m>invamp</m> is <b>on</b>, <o>irextract~</o> will perform deconvolution taking into account the output level. This correctly measures the gain of the system tested. <br />
				As for acoustic measurements the exact gain of the analog part of the system is essentially arbitrary (due to mic gains etc) so <m>invamp</m> defaults to <b>off</b>. <br />
				When measuring digital systems etc, or situations where the gain is controlled, <m>invamp</m> should be switched <b>on</b> to correctly capture gain information.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Invert Amplitude" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="irgain" get="1" set="1" type="float" size="1">
			<digest>
				Overall Gain in dB
			</digest>
			<description>
				An arbitrary gain factor in <b>dB</b> can be applied to any recording. <br />
				IR recordings may produce very high or very low overall gains. One can mitigate this with the <m>irgain</m> attribute. <br />
				For example, measuring real rooms tends to produce low levels and thus IRs need to be boosted by circa 20..40 <b>dB</b> with this attribute. <br />
				<b>units: dB, float, default: 0</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Overall Gain in dB" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="dB" />
			</attributelist>
		</attribute>
		<attribute name="readchan" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Read Channel
			</digest>
			<description>
				Sets the channel number for <o>buffer~</o> reading (1-4). If the specified channel does not exist the value is wrapped within the existing number of channels (so 3 will read from channel 1 of a two-channel <o>buffer~</o>, 4 from channel 2). <br />
				<b>units: int, default: 1, range: 1..4</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Read Channel" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="resize" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Resize
			</digest>
			<description>
				If on, the <o>buffer~</o> will resize to the necessary size before write. Resizing erases all contents of the <o>buffer~</o>. <br />
				Otherwise, output will ONLY happen if there is enough room to write the entire output, leaving the latter contents of the <o>buffer~</o> and other <o>buffer~</o> channels unaffected. <br />
				<b>units: flag, default: 1, range: 0/1</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Resize" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="writechan" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Write Channel
			</digest>
			<description>
				Sets the channel number for <o>buffer~</o> writing (1-4). If the specified channel does not exist the value is wrapped within the existing number of channels (so 3 will write to channel 1 of a two-channel <o>buffer~</o>, 4 to channel 2). <br />
				<b>units: int, default: 1, range: 1..4</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Write Channel" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		Further Reading: <br />
		<br />
		ESS Measurement: <br />
		<br />
		A. Farina, “Simultaneous measurement of impulse response and distortion with a swept-sine technique,” in Audio Engineering Society Convention 108, 2 2000 <br />
		<br />
		A. Farina, “Advancements in impulse response measure- ments by sine sweeps,” in Audio Engineering Society Convention 122, 5 2007 <br />
		<br />
		A. Nova ́k and, L. Simon, F. Kadlec, and P. Lotton, “Nonlinear system identification using exponential swept-sine signal,” Instrumentation and Measure- ment, IEEE Transactions on, vol. 59, no. 8, pp. 2220 –2229, Aug. 2010 <br />
		<br />
		MLS Measurement: <br />
		<br />
		D. D. Rife and J. Vanderkooy, “Transfer-function measurement with maximum-length sequences,” J. Audio Eng. Soc, vol. 37, no. 6, pp. 419–444, 1989 <br />
		<br />
		Comparisions: <br />
		<br />
		G.-B. Stan, J.-J. Embrechts, and D. Archambeau, “Comparison of different impulse response mea- surement techniques,” J. Audio Eng. Soc, vol. 50, no. 4, pp. 249–262, 2002 <br />
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="iralign~" />
		<seealso name="iraverage~" />
		<seealso name="irinvert~" />
		<seealso name="irmeasure~" />
		<seealso name="irnonlin~" />
		<seealso name="irphase~" />
		<seealso name="irplapprox~" />
		<seealso name="irreference~" />
		<seealso name="irstats~" />
		<seealso name="irsweeps~" />
		<seealso name="irtransaural~" />
		<seealso name="irtrimnorm~" />
		<seealso name="iruser~" />
		<seealso name="irvalue~" />
		<seealso name="bufconvolve~" />
		<seealso name="bufresample~" />
		<seealso name="bufreverse~" />
		<seealso name="morphfilter~" />
		<seealso name="multiconvolve~" />
		<seealso name="spectrumdraw~" />
        <seealso name="hirttutorials" type="tutorial" module="hirt" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (messages)">
			<description>
				Instructions to <o>irextract~</o>.
				<m>sweep</m>, <m>mls</m>, <m>white</m>, <m>brown</m>, <m>pink</m>, <m>clear</m>, <m>getir</m>, <m>dump</m>
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (bang)">
			<description>
				<m>Bang</m> on completion of called process.
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		Further Reading: <br />
		<br />
		ESS Measurement: <br />
		<br />
		A. Farina, “Simultaneous measurement of impulse response and distortion with a swept-sine technique,” in Audio Engineering Society Convention 108, 2 2000 <br />
		<br />
		A. Farina, “Advancements in impulse response measure- ments by sine sweeps,” in Audio Engineering Society Convention 122, 5 2007 <br />
		<br />
		A. Nova ́k and, L. Simon, F. Kadlec, and P. Lotton, “Nonlinear system identification using exponential swept-sine signal,” Instrumentation and Measure- ment, IEEE Transactions on, vol. 59, no. 8, pp. 2220 –2229, Aug. 2010 <br />
		<br />
		MLS Measurement: <br />
		<br />
		D. D. Rife and J. Vanderkooy, “Transfer-function measurement with maximum-length sequences,” J. Audio Eng. Soc, vol. 37, no. 6, pp. 419–444, 1989 <br />
		<br />
		Comparisions: <br />
		<br />
		G.-B. Stan, J.-J. Embrechts, and D. Archambeau, “Comparison of different impulse response mea- surement techniques,” J. Audio Eng. Soc, vol. 50, no. 4, pp. 249–262, 2002 <br />
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
impulse response, buffer, convolution.
			</description>
		</entry>
	</misc>

</c74object>