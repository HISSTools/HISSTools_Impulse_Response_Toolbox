<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been (sort of) automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="irmeasure~" module="hirt">

	<digest>
		Measure IRs of single or multichannel systems using a range of excitation signals
	</digest>

	<description>
		The <o>irmeasure~</o> object can be used to measure IRs using the ESS (exponentially swept sine), MLS (maximum length sequences) or various coloured-noise signals (which whilst less accurate, may be preferable in occupied rooms where a rough estimate is acceptable).
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">Alex Harker</metadata>
		<metadata name="tag">HIRT</metadata>
		<metadata name="tag">HIRT Objects</metadata>
		<metadata name="tag">HIRT Impulse Response</metadata>
		<metadata name="tag">HIRT Measurement</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Audio Input 1 / Instructions In
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Audio Inlets
			</digest>
			<description>
				The number of audio signal inputs for realtime processing is determined by the argument(s) to the object (up to 128)
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Audio Outlets
			</digest>
			<description>
				The number of audio signal outputs for realtime processing is determined by the argument(s) to the object (up to 128)
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Penultimate (right) outlet: 0..1 or ms
			</digest>
			<description>
				Penultimate (right) outlet: Measurement Progress (0..1 or ms depending on the <m>absprogress</m> attribute)
			</description>
		</outlet>
		<outlet id="2" type="INLET_TYPE">
			<digest>
				Right outlet: <m>bang</m>
			</digest>
			<description>
				Final (rightmost) outlet: <m>bang</m> on completion of called process
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="num_ins" optional="1" type="int">
			<digest>
				Number of measurement inputs
			</digest>
			<description>
				Number of inputs, default = <b>1</b>, maximum = <b>128</b>
			</description>
		</objarg>
		<objarg name="num_outs" optional="1" type="int">
			<digest>
				Number of measurement outputs
			</digest>
			<description>
				Number of outputs, default = <b>1</b>, maximum = <b>128</b>
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="activeins">
			<arglist />
			<digest>
				Number of active inputs
			</digest>
			<description>
				One can set the number of active measurement inputs and outputs, to enable more generalised patching. <br />
			</description>
		</method>
		<method name="activeouts">
			<arglist />
			<digest>
				Number of active outputs
			</digest>
			<description>
				One can set the number of active measurement inputs and outputs, to enable more generalised patching. <br />
			</description>
		</method>
		<method name="brown">
			<arg name="length" optional="1" type="int" />
			<arg name="fade_in" optional="1" type="int/float" />
			<arg name="fade_out" optional="1" type="int/float" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Make a brown-noise recording
			</digest>
			<description>
				Syntax: <b>brown <m>[&lt;int: length&gt;]</m> <m>[&lt;int/float: fade_in&gt;]</m> <m>[&lt;int/float: fade_out&gt;]</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				Note that noise signals will be identical each time when the same parameters are used. <br />
				<m>brown</m> defaults: 10000ms / 10ms / 10ms / 5000ms <br />
			</description>
		</method>
		<method name="clear">
			<arglist />
			<digest>
				Cancel measurements and <m>clear</m> all allocated memory
			</digest>
			<description>
			</description>
		</method>
		<method name="dump">
			<arg name="in_chan" optional="1" type="int" />
			<arg name="output_buffer_name" optional="0" type="symbol" />
			<digest>
				Place the internal processed ouput for one input channel into a named <o>buffer~</o>
			</digest>
			<description>
				Syntax: <b>dump <m>[&lt;int: in_chan&gt;]</m> <m>&lt;symbol: output_buffer_name&gt;</m> </b><br />				<br />
				<b>!! The <m>dump</m> message can only be used AFTER processing <o>irmeasure~</o> !!</b> <br />
				<br />
				The <m>dump</m> message allows the processsed recording (containing all IRs for a given input channel, including nonlinear components where relevant) for one of the measurement input channels to be dumped to a named <o>buffer~</o>. <br />
			</description>
		</method>
		<method name="extract">
			<arg name="in_chan" optional="1" type="int" />
			<arg name="output_buffer_name" optional="0" type="symbol" />
			<digest>
				Extract the internal recording for one input channel into a named <o>buffer~</o>
			</digest>
			<description>
				Syntax: <b>extract <m>[&lt;int: in_chan&gt;]</m> <m>&lt;symbol: output_buffer_name&gt;</m> </b><br />				<br />
				<b>!! The <m>extract</m> message can only be used AFTER processing <o>irmeasure~</o> !!</b> <br />
				<br />
				The <m>extract</m> message allows the recording (without processing) for one of the measurement input channels to be extracted to a named <o>buffer~</o>. <br />
			</description>
		</method>
		<method name="getir">
			<arg name="in_chan" optional="1" type="int" />
			<arg name="buffer_name" optional="0" type="symbol" />
			<arg name="out_chan" optional="1" type="int" />
			<arg name="harmonic" optional="1" type="int" />
			<digest>
				Retrieve IR
			</digest>
			<description>
				Syntax: <b>getir <m>[&lt;int: in_chan&gt;]</m> <m>&lt;symbol: buffer_name&gt;</m> <m>[&lt;int: out_chan&gt;]</m> <m>[&lt;int: harmonic&gt;]</m> </b><br />				<br />
				<b>!! IRs must be retrieved to a <o>buffer~</o> with this message !!</b> <br />
				<br />
				<m>getir</m> defaults: 1 / [name] / 1 / 1. N.B. the harmonics arg (arg 3) must be an <m>integer</m> <b>&gt;= 1</b>. <br />
			</description>
		</method>
		<method name="mls">
			<arg name="order" optional="1" type="int" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Make a Maximum Length Sequence recording
			</digest>
			<description>
				Syntax: <b>mls <m>[&lt;int: order&gt;]</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				The MLS is an ordered noise-like signal containing all possible sequencs of -1 and 1 of a given length (according to the <m>order</m>). The overall length of the MLS is (2^N) -1 samples where N is the <m>order</m>. <br />
				<m>mls</m> defaults: 18 / 5000ms <br />
			</description>
		</method>
		<method name="pink">
			<arg name="length" optional="1" type="int" />
			<arg name="fade_in" optional="1" type="int/float" />
			<arg name="fade_out" optional="1" type="int/float" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Make a pink-noise recording
			</digest>
			<description>
				Syntax: <b>pink <m>[&lt;int: length&gt;]</m> <m>[&lt;int/float: fade_in&gt;]</m> <m>[&lt;int/float: fade_out&gt;]</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				Note that noise signals will be identical each time when the same parameters are used. <br />
				<m>pink</m> defaults: 10000ms / 10ms / 10ms / 5000ms <br />
			</description>
		</method>
		<method name="reprocess">
			<arglist />
			<digest>
				Reprocess the recordings using different settings
			</digest>
			<description>
				Once the measurement is finished the recordings are automatically processed. The <m>reprocess</m> message allows one to reprocess the recordings using different deconvolution settings. See the <m>deconv*</m> attributes for details.
			</description>
		</method>
		<method name="signal">
			<arglist />
			<digest>
				Audio signal inlets
			</digest>
			<description>
				The number of audio signal inputs is determined by the argument(s) to the object. Minimum = <b>1</b>, maximum = <b>128</b>. <br />
			</description>
		</method>
		<method name="stop">
			<arglist />
			<digest>
				Cancel measurement
			</digest>
			<description>
			</description>
		</method>
		<method name="sweep">
			<arg name="low_freq" optional="1" type="int/float" />
			<arg name="high_freq" optional="1" type="int/float" />
			<arg name="length" optional="1" type="int" />
			<arg name="fade_in" optional="1" type="int/float" />
			<arg name="fade_out" optional="1" type="int/float" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Make a sweep recording
			</digest>
			<description>
				Syntax: <b>sweep <m>[&lt;int/float: low_freq&gt;]</m> <m>[&lt;int/float: high_freq&gt;]</m> <m>[&lt;int: length&gt;]</m> <m>[&lt;int/float: fade_in&gt;]</m> <m>[&lt;int/float: fade_out&gt;]</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				The ESS (exponentially swept sine) is a signal with good signal to noise and distortion rejection properties for IR measurement. The inverse signal can be convolved directly with the resultant recordings, without the need for deconvolution. <br />
				<m>sweep</m> defaults: 20Hz / nyquist / 30000ms / 50ms / 10ms / 5000ms <br />
			</description>
		</method>
		<method name="tone">
			<arg name="frequency" optional="0" type="int/float" />
			<arg name="out_chan" optional="1" type="int" />
			<digest>
				Output a test tone
			</digest>
			<description>
				Syntax: <b>tone <m>&lt;int/float: frequency&gt;</m> <m>[&lt;int: out_chan&gt;]</m> </b><br />				<br />
				<m>tone</m> defaults: frequency <b>Hz</b> / <b>0</b> (= all)
			</description>
		</method>
		<method name="white">
			<arg name="length" optional="1" type="int" />
			<arg name="fade_in" optional="1" type="int/float" />
			<arg name="fade_out" optional="1" type="int/float" />
			<arg name="ir_length" optional="1" type="int" />
			<digest>
				Make a white-noise recording
			</digest>
			<description>
				Syntax: <b>white <m>[&lt;int: length&gt;]</m> <m>[&lt;int/float: fade_in&gt;]</m> <m>[&lt;int/float: fade_out&gt;]</m> <m>[&lt;int: ir_length&gt;]</m> </b><br />				<br />
				Note that noise signals will be identical each time when the same parameters are used. <br />
				<m>white</m> defaults: 10000ms / 10ms / 10ms / 5000ms <br />
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="absprogress" get="1" set="1" type="int" size="1">
			<digest>
				Absolute Progress
			</digest>
			<description>
				When the <m>absprogress</m> is <b>on</b>, the progress output is in milliseconds, otherwise the progress output is normalised <b>0..1</b>.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Absolute Progress" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="amp" get="1" set="1" type="float" size="1">
			<digest>
				Signal Maximum Amplitude (dB)
			</digest>
			<description>
				Sets the maximum ampltiude of the generated signal in <b>dB</b>.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Signal Maximum Amplitude (dB)" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="ampcurve" get="1" set="1" type="atom_array" size="3">
			<digest>
				Sweep Amplitude Curve Specification
			</digest>
			<description>
				Instead of producing sweeps with a flat amplitude response the ampltiude can be varied with frequency, so as to best suit the measured system (for instance using lower ampltudes at low and high frequencies, thus avoiding distortion of the measurement speaker). <br />
				When blank, sweeps will be flat. Otherwise you should specify the ampitude response using frequency (<b>Hz</b>) &amp; amplitude (<b>dB</b>) pairs. <br />
				Example: <b><m>ampcurve</m> 10 -20 40 0 16000 0 19000 -25</b> <br />
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Sweep Amplitude Curve Specification" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="bandlimit" get="1" set="1" type="int" size="1">
			<digest>
				Bandlimit Sweep Measurements
			</digest>
			<description>
				When <m>bandlimit</m> is <b>on</b>, measurements taken using the <m>sweep</m> signal are automatically bandlimited to the range of the sweep (the deconvolution filter is automatically generated, bypassing the deconvolution filter settings). <br />
				The fade times determine the steepness of the filter slope at low and high frequencies (shorter fade in times give a steeper <b>LF</b> rolloff, shorter fade out times give a steeper <b>HF</b> rolloff). This is the most appropriate setting for acoustic measurements. <br />
				When <b>off</b>, the deconvolution filter settings are used for sweep measurements. This may be more appropriate for measuring within a digital system, or when hand tuning of settings is desirable. <br />
				This attribute does not affect measruements using the <m>mls</m> or <m>coloured noise</m> signals.
				<br />
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Bandlimit Sweep Measurements" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="deconvdelay" get="1" set="1" type="atom" size="1">
			<digest>
				Deconvolution Modelling Delay
			</digest>
			<description>
				Deconvolution can result in time-aliasing. In order to make sure that the resultant IR is correctly contained within the period of the FFT, it may be necessary to introduce a modelling delay (shifting the output of the deconvolution). <br />
				This delay can either be set in milliseconds or using the symbol 'center' which sets the delay to half of the FFT size. <br />
				This attribute is not available in the <o>irmeasure~</o> &amp; <o>irextract~</o> objects, as the timing is tightly controlled by the synchronous recording/playback process, making a modelling delay unnecessary. <br />
				<b>units: milliseconds or symbol</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Modelling Delay" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvfilter" get="1" set="1" type="atom_array" size="0">
			<digest>
				Deconvolution Filter Specification
			</digest>
			<description>
				Regardless of the deconvolution mode (<m>deconvmode</m>) it is necessary to set a specification for how to control the deconvolution over the frequency range. The <m>deconvfilter</m> specification sets a frequency curve to apply to the relevant mode. <br />
				You may either specify a static value in <b>dB</b>, or a <m>list</m> of <b>freq/dB</b> values to vary the specification with frequency. For <m>regularisation</m> this sets the constant value to add to the divisor. <br />
				For <m>clipping</m> it sets the minimum values allowed for the division. For <m>filter</m> it sets the shape of the filter. <br />
				Typically, for standard usage, very low or high frequencies are liable to blowup through overcorrection or numeric error. Thus higher values for <m>regularisation</m> and <m>clipping</m> are appropraite at low/high frequencies. <br />
				The <m>filter</m> mode works in the inverse, and lower values (less gain) are generally more appropriate for extremes of frequency. <br />
				Additionally you may specify the name of a <o>buffer~</o> as the filter specification in which case the power spectrum of the <o>buffer~</o> is used to determine the specification for <m>regularisation</m> and <m>clipping</m> modes, <br />
				and the <o>buffer~</o> is applied directly as a convolution filter in <m>filter</m> mode (ignoring the <m>deconvphase</m> attribute setting in this case). <br />
				This allows a high degree of control of the process for special applications or custom solutions. <br />
				<b>units: symbol &amp; list</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Specification" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvmode" get="1" set="1" type="int" size="1">
			<digest>
				Deconvolution Filter Mode
			</digest>
			<description>
				Deconvolution must be controlled so as to prevent filter blow-up or excessive time-aliasing. The control is equivalent to filtering the result of a staightforward complex division in the frequency domain (hence the term filter). The three modes are: <br />
				<b>0</b>, Regularisation: Regularise the division by adding a constant to the division <br />
				<b>1</b>, Clipping: Clip the denominator in the division <br />
				<b>2</b>, Specify the filter explicitly <br />
				<b>units: int, default: 0, range: 0..2</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Mode" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="deconvphase" get="1" set="1" type="atom" size="1">
			<digest>
				Deconvolution Filter Phase
			</digest>
			<description>
				The method by which deconvolution is controlled acts as a FIR filter on result of the 'true deconvolution'. This filter will produce time smearing of the result. This can result in pre or post ring in the resultant IR. <br />
				By controlling the phase of the implicit filter we can control this ring. <br />
				The default is <b>minimum</b> phase which post-rings only. The phase may either be specified as a float value between <b>0</b> and <b>1</b> (where <b>0</b> is <b>minimum</b> phase, <b>0.5</b> is <b>linear</b> phase and <b>1</b> is <b>maximum</b> phase), <br />
				or using any of the following symbols: <br />
				<b>min</b> / <b>minimum</b>: Minimum Phase <br />
				<b>lin</b> / <b>linear</b>: Linear Phase <br />
				<b>max</b> / <b>maximum</b>: Maximum Phase <br />
				<b>units: float or symbol, default: 0 / minimum, range: 0..1 or min/lin/max</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Phase" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvrange" get="1" set="1" type="atom_array" size="0">
			<digest>
				Deconvolution Filter Range
			</digest>
			<description>
				When <m>deconvmode</m> is <m>clipping</m> the denominator of the divsion can be clipped to both minimum values (controlling peaks in the output) and also maximum values (controlling dips in the output). <br />
				The <m>deconvrange</m> attibute sets the maximum values in relation to the filter specification. Similarly to the deconvolution filter specification (<m>deconvfilter</m>),
				you may either specify a single value in <b>dB</b> or use a list of <b>freq/dB</b> pairs to vary the range with frequency. <br />
				<b>units: symbol &amp; list</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Range" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="invamp" get="1" set="1" type="int" size="1">
			<digest>
				Invert Amplitude
			</digest>
			<description>
				When <m>invamp</m> is <b>on</b>, <o>irextract~</o> will perform deconvolution taking into account the output level. This correctly measures the gain of the system tested. <br />
				As for acoustic measurements the exact gain of the analog part of the system is essentially arbitrary (due to mic gains etc) so <m>invamp</m> defaults to <b>off</b>. <br />
				When measuring digital systems etc, or situations where the gain is controlled, <m>invamp</m> should be switched <b>on</b> to correctly capture gain information.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Invert Amplitude" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="irgain" get="1" set="1" type="float" size="1">
			<digest>
				Overall Gain in dB
			</digest>
			<description>
				An arbitrary gain factor in <b>dB</b> can be applied to any recording. <br />
				IR recordings may produce very high or very low overall gains. One can mitigate this with the <m>irgain</m> attribute. <br />
				For example, measuring real rooms tends to produce low levels and thus IRs need to be boosted by circa 20..40 <b>dB</b> with this attribute. <br />
				<b>units: dB, float, default: 0</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Overall Gain in dB" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="dB" />
			</attributelist>
		</attribute>
		<attribute name="resize" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Resize
			</digest>
			<description>
				If on, the <o>buffer~</o> will resize to the necessary size before write. Resizing erases all contents of the <o>buffer~</o>. <br />
				Otherwise, output will ONLY happen if there is enough room to write the entire output, leaving the latter contents of the <o>buffer~</o> and other <o>buffer~</o> channels unaffected. <br />
				<b>units: flag, default: 1, range: 0/1</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Resize" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="writechan" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Write Channel
			</digest>
			<description>
				Sets the channel number for <o>buffer~</o> writing (1-4). If the specified channel does not exist the value is wrapped within the existing number of channels (so 3 will write to channel 1 of a two-channel <o>buffer~</o>, 4 to channel 2). <br />
				<b>units: int, default: 1, range: 1..4</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Write Channel" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		As well as handling multichannel situations, the object also deals with the processing and chopping of IRs (including the relative timing of non-linear components when using the ESS signal), allowing the user to retrieve the IRs directly without needing to carry out recording, deconvolution and
		chopping processes manually. <br />
		In use, an excitation signal is sent to the measurement outputs of the object, (which are routed to the input of a system - e.g. a speaker in a room) whilst the object simultaneously records the output of the same system (captured for instance by a mic in a room) - thus it is necessary to create a loop through the sytem from output to input. <br />
		<br />
		Further Reading: <br />
		<br />
		ESS Measurement: <br />
		<br />
		A. Farina, “Simultaneous measurement of impulse response and distortion with a swept-sine technique,” in Audio Engineering Society Convention 108, 2 2000 <br />
		<br />
		A. Farina, “Advancements in impulse response measure- ments by sine sweeps,” in Audio Engineering Society Convention 122, 5 2007 <br />
		<br />
		A. Nova ́k and, L. Simon, F. Kadlec, and P. Lotton, “Nonlinear system identification using exponential swept-sine signal,” Instrumentation and Measure- ment, IEEE Transactions on, vol. 59, no. 8, pp. 2220 –2229, Aug. 2010 <br />
		<br />
		MLS Measurement: <br />
		<br />
		D. D. Rife and J. Vanderkooy, “Transfer-function measurement with maximum-length sequences,” J. Audio Eng. Soc, vol. 37, no. 6, pp. 419–444, 1989 <br />
		<br />
		Comparisions: <br />
		<br />
		G.-B. Stan, J.-J. Embrechts, and D. Archambeau, “Comparison of different impulse response mea- surement techniques,” J. Audio Eng. Soc, vol. 50, no. 4, pp. 249–262, 2002 <br />
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="iralign~" />
		<seealso name="iraverage~" />
		<seealso name="irextract~" />
		<seealso name="irinvert~" />
		<seealso name="irnonlin~" />
		<seealso name="irphase~" />
		<seealso name="irplapprox~" />
		<seealso name="irreference~" />
		<seealso name="irstats~" />
		<seealso name="irsweeps~" />
		<seealso name="irtransaural~" />
		<seealso name="irtrimnorm~" />
		<seealso name="iruser~" />
		<seealso name="irvalue~" />
		<seealso name="bufconvolve~" />
		<seealso name="bufresample~" />
		<seealso name="bufreverse~" />
		<seealso name="morphfilter~" />
		<seealso name="multiconvolve~" />
		<seealso name="spectrumdraw~" />
		<seealso name="hirt.irmaker~" />
        <seealso name="hirttutorials" type="tutorial" module="hirt" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (signal)">
			<description>
				Audio Input 1 / Instructions In.
			</description>
		</entry>
		<entry name ="Inlet 2 (signal)">
			<description>
				Audio Inlets.
				The number of audio signal inputs for realtime processing is determined by the argument(s) to the object (up to 128)
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (signal)">
			<description>
				Audio Outlets.
				The number of audio signal outputs for realtime processing is determined by the argument(s) to the object (up to 128)
			</description>
		</entry>
		<entry name ="Outlet 2 (signal)">
			<description>
				Penultimate (right) outlet: 0..1 or ms.
				Penultimate (right) outlet: Measurement Progress (0..1 or ms depending on the <m>absprogress</m> attribute)
			</description>
		</entry>
		<entry name ="Outlet 3 (bang)">
			<description>
				Right outlet: <m>bang</m>.
				Final (rightmost) outlet: <m>bang</m> on completion of called process
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		As well as handling multichannel situations, the object also deals with the processing and chopping of IRs (including the relative timing of non-linear components when using the ESS signal), allowing the user to retrieve the IRs directly without needing to carry out recording, deconvolution and
		chopping processes manually. <br />
		In use, an excitation signal is sent to the measurement outputs of the object, (which are routed to the input of a system - e.g. a speaker in a room) whilst the object simultaneously records the output of the same system (captured for instance by a mic in a room) - thus it is necessary to create a loop through the sytem from output to input. <br />
		<br />
		Further Reading: <br />
		<br />
		ESS Measurement: <br />
		<br />
		A. Farina, “Simultaneous measurement of impulse response and distortion with a swept-sine technique,” in Audio Engineering Society Convention 108, 2 2000 <br />
		<br />
		A. Farina, “Advancements in impulse response measure- ments by sine sweeps,” in Audio Engineering Society Convention 122, 5 2007 <br />
		<br />
		A. Nova ́k and, L. Simon, F. Kadlec, and P. Lotton, “Nonlinear system identification using exponential swept-sine signal,” Instrumentation and Measure- ment, IEEE Transactions on, vol. 59, no. 8, pp. 2220 –2229, Aug. 2010 <br />
		<br />
		MLS Measurement: <br />
		<br />
		D. D. Rife and J. Vanderkooy, “Transfer-function measurement with maximum-length sequences,” J. Audio Eng. Soc, vol. 37, no. 6, pp. 419–444, 1989 <br />
		<br />
		Comparisions: <br />
		<br />
		G.-B. Stan, J.-J. Embrechts, and D. Archambeau, “Comparison of different impulse response mea- surement techniques,” J. Audio Eng. Soc, vol. 50, no. 4, pp. 249–262, 2002 <br />
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
impulse response, buffer, convolution, excitation.
			</description>
		</entry>
	</misc>

</c74object>