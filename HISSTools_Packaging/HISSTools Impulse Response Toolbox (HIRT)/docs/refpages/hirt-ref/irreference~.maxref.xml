<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="irreference~" module="hirt">

	<digest>
		Estimate system IRs by relative comparison of two recorded inputs
	</digest>

	<description>
		The <o>irreference~</o> object can be used either to estimate IRs using an arbitrary excitation signal (such as music), or to estimate the relative IR between two systems.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">Alex Harker</metadata>
		<metadata name="tag">HIRT</metadata>
		<metadata name="tag">HIRT Objects</metadata>
		<metadata name="tag">HIRT Impulse Response</metadata>
		<metadata name="tag">HIRT Measurement</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Audio Reference Input / Instructions In
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Audio Measurement Inlets
			</digest>
			<description>
				The number of audio signal inputs for realtime processing is determined by the argument(s) to the object
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Left outlet: 0..1 or ms
			</digest>
			<description>
				Left outlet: Measurement Progress (0..1 or ms depending on the <m>absprogress</m> attribute)
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Right outlet: <m>bang</m>
			</digest>
			<description>
				Rightmost outlet: <m>bang</m> on completion of called process
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="num_ref_ins" optional="1" type="int">
			<digest>
				Number of reference inputs
			</digest>
			<description>
				Number of inputs, default = <b>1</b> <br />
				N.B. The <o>irreference~</o> object always has one reference input, plus the number of additional inputs specified by this argument. For example, if this argument is <b>3</b> (the default is <b>1</b>), the object will have four inputs. <br />
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="activeins">
			<arglist />
			<digest>
				Number of active inputs
			</digest>
			<description>
				One can set the number of active measurement inputs and outputs, to enable more generalised patching. <br />
			</description>
		</method>
		<method name="clear">
			<arglist />
			<digest>
				Cancel measurements and <m>clear</m> all allocated memory
			</digest>
			<description>
			</description>
		</method>
		<method name="dump">
			<arg name="output_buffer_name" optional="0" type="symbol" />
			<digest>
				Place the internal processed ouput for one input channel into a named <o>buffer~</o>
			</digest>
			<description>
				Syntax: <b>dump <m>&lt;symbol: output_buffer_name&gt;</m> </b><br />				<br />
				<b>!! The <m>dump</m> message can only be used AFTER processing <o>irreference~</o> !!</b> <br />
				<br />
				The <m>dump</m> message allows the processsed recording (containing all IRs for a given input channel, including nonlinear components where relevant) for one of the measurement input channels to be dumped to a named <o>buffer~</o>. <br />
			</description>
		</method>
		<method name="extract">
			<arg name="in_chan" optional="1" type="int" />
			<arg name="output_buffer_name" optional="0" type="symbol" />
			<digest>
				Extract the internal recording for one input channel into a named <o>buffer~</o>
			</digest>
			<description>
				Syntax: <b>extract <m>[&lt;int: in_chan&gt;]</m> <m>&lt;symbol: output_buffer_name&gt;</m> </b><br />				<br />
				<b>!! The <m>extract</m> message can only be used AFTER processing <o>irreference~</o> !!</b> <br />
				<br />
				The <m>extract</m> message allows the recording (without processing) for one of the measurement input channels to be extracted to a named <o>buffer~</o>. <br />
			</description>
		</method>
		<method name="finish">
			<arglist />
			<digest>
				Finish recording early but still process to allow IR retrieval
			</digest>
			<description>
			</description>
		</method>
		<method name="getir">
			<arg name="in_chan" optional="1" type="int" />
			<arg name="output_buffer_name" optional="0" type="symbol" />
			<digest>
				Retrieve IR
			</digest>
			<description>
				Syntax: <b>getir <m>[&lt;int: in_chan&gt;]</m> <m>&lt;symbol: output_buffer_name&gt;</m> </b><br />				<br />
				<b>!! IRs must be retrieved to a <o>buffer~</o> with the <m>getir</m> message AFTER processing !!</b> <br />
				<br />
				<m>getir</m> defaults: 1 / [name] <br />
			</description>
		</method>
		<method name="rec">
			<arg name="record_length" optional="1" type="int" />
			<arg name="expected_IR_length" optional="1" type="int" />
			<digest>
				Record reference IR(s)
			</digest>
			<description>
				Syntax: <b>rec <m>[&lt;int: record_length&gt;]</m> <m>[&lt;int: expected_IR_length&gt;]</m> </b><br />				<br />
				The <m>rec</m> message starts recording the reference and measurement inputs. After recording the deconvolution processing is automatically started. <br />
				<m>rec</m> defaults: 30000 ms / 5000 ms <br />
			</description>
		</method>
		<method name="reprocess">
			<arglist />
			<digest>
				Reprocess the recordings (using different deconvolution settings)
			</digest>
			<description>
				Once the <o>irreference~</o> measurement has finished, the recordings are automatically processed. The <m>reprocess</m> message allows for reprocessing the recordings using different deconvolution settings (see <m>deconv*</m> attributes).
			</description>
		</method>
		<method name="signal">
			<arglist />
			<digest>
				Audio signal inlets
			</digest>
			<description>
				The number of audio signal inputs is determined by the argument(s) to the object <br />
				The <o>irreference~</o> object always has one reference input, plus the number of specified measurement inputs (see the num_ref_ins argument to the object). The resultant IRs are the measurement inputs deconvolved by the reference input.
			</description>
		</method>
		<method name="stop">
			<arglist />
			<digest>
				Cancel measurement
			</digest>
			<description>
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="absprogress" get="1" set="1" type="int" size="1">
			<digest>
				Absolute Progress
			</digest>
			<description>
				When the <m>absprogress</m> is <b>on</b>, the progress output is in milliseconds, otherwise the progress output is normalised <b>0..1</b>.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Absolute Progress" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="deconvdelay" get="1" set="1" type="atom" size="1">
			<digest>
				Deconvolution Modelling Delay
			</digest>
			<description>
				Deconvolution can result in time-aliasing. In order to make sure that the resultant IR is correctly contained within the period of the FFT, it may be necessary to introduce a modelling delay (shifting the output of the deconvolution). <br />
				This delay can either be set in milliseconds or using the symbol 'center' which sets the delay to half of the FFT size. <br />
				This attribute is not available in the <o>irmeasure~</o> &amp; <o>irextract~</o> objects, as the timing is tightly controlled by the synchronous recording/playback process, making a modelling delay unnecessary. <br />
				<b>units: milliseconds or symbol</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Modelling Delay" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvfilter" get="1" set="1" type="atom_array" size="0">
			<digest>
				Deconvolution Filter Specification
			</digest>
			<description>
				Regardless of the deconvolution mode (<m>deconvmode</m>) it is necessary to set a specification for how to control the deconvolution over the frequency range. The <m>deconvfilter</m> specification sets a frequency curve to apply to the relevant mode. <br />
				You may either specify a static value in <b>dB</b>, or a <m>list</m> of <b>freq/dB</b> values to vary the specification with frequency. For <m>regularisation</m> this sets the constant value to add to the divisor. <br />
				For <m>clipping</m> it sets the minimum values allowed for the division. For <m>filter</m> it sets the shape of the filter. <br />
				Typically, for standard usage, very low or high frequencies are liable to blowup through overcorrection or numeric error. Thus higher values for <m>regularisation</m> and <m>clipping</m> are appropraite at low/high frequencies. <br />
				The <m>filter</m> mode works in the inverse, and lower values (less gain) are generally more appropriate for extremes of frequency. <br />
				Additionally you may specify the name of a <o>buffer~</o> as the filter specification in which case the power spectrum of the <o>buffer~</o> is used to determine the specification for <m>regularisation</m> and <m>clipping</m> modes, <br />
				and the <o>buffer~</o> is applied directly as a convolution filter in <m>filter</m> mode (ignoring the <m>deconvphase</m> attribute setting in this case). <br />
				This allows a high degree of control of the process for special applications or custom solutions. <br />
				<b>units: symbol &amp; list</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Specification" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvmode" get="1" set="1" type="int" size="1">
			<digest>
				Deconvolution Filter Mode
			</digest>
			<description>
				Deconvolution must be controlled so as to prevent filter blow-up or excessive time-aliasing. The control is equivalent to filtering the result of a staightforward complex division in the frequency domain (hence the term filter). The three modes are: <br />
				<b>0</b>, Regularisation: Regularise the division by adding a constant to the division <br />
				<b>1</b>, Clipping: Clip the denominator in the division <br />
				<b>2</b>, Specify the filter explicitly <br />
				<b>units: int, default: 0, range: 0..2</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Mode" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="deconvphase" get="1" set="1" type="atom" size="1">
			<digest>
				Deconvolution Filter Phase
			</digest>
			<description>
				The method by which deconvolution is controlled acts as a FIR filter on result of the 'true deconvolution'. This filter will produce time smearing of the result. This can result in pre or post ring in the resultant IR. <br />
				By controlling the phase of the implicit filter we can control this ring. <br />
				The default is <b>minimum</b> phase which post-rings only. The phase may either be specified as a float value between <b>0</b> and <b>1</b> (where <b>0</b> is <b>minimum</b> phase, <b>0.5</b> is <b>linear</b> phase and <b>1</b> is <b>maximum</b> phase), <br />
				or using any of the following symbols: <br />
				<b>min</b> / <b>minimum</b>: Minimum Phase <br />
				<b>lin</b> / <b>linear</b>: Linear Phase <br />
				<b>max</b> / <b>maximum</b>: Maximum Phase <br />
				<b>units: float or symbol, default: 0 / minimum, range: 0..1 or min/lin/max</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Phase" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvrange" get="1" set="1" type="atom_array" size="0">
			<digest>
				Deconvolution Filter Range
			</digest>
			<description>
				When <m>deconvmode</m> is <m>clipping</m> the denominator of the divsion can be clipped to both minimum values (controlling peaks in the output) and also maximum values (controlling dips in the output). <br />
				The <m>deconvrange</m> attibute sets the maximum values in relation to the filter specification. Similarly to the deconvolution filter specification (<m>deconvfilter</m>),
				you may either specify a single value in <b>dB</b> or use a list of <b>freq/dB</b> pairs to vary the range with frequency. <br />
				<b>units: symbol &amp; list</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Range" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="resize" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Resize
			</digest>
			<description>
				If on, the <o>buffer~</o> will resize to the necessary size before write. Resizing erases all contents of the <o>buffer~</o>. <br />
				Otherwise, output will ONLY happen if there is enough room to write the entire output, leaving the latter contents of the <o>buffer~</o> and other <o>buffer~</o> channels unaffected. <br />
				<b>units: flag, default: 1, range: 0/1</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Resize" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="smoothamount" get="1" set="1" type="float_array" size="0">
			<digest>
				Smoothing Amounts
			</digest>
			<description>
				The spectral smoothing can change in linear width as the centre frequency changes. Typically, it makes sense to smooth more at high frequencies and less at low ones (corresponding to human perception). <br />
				The smoothing amounts set the smoothing widths in normalised linear frequency (where <b>0</b> is <b>0 Hz</b> and <b>0.5</b> is the <b>nyquist</b> frequency). <br />
				If one value only is given then the width of the smoothing window at <b>0 Hz</b> will be <b>0 Hz</b> and the width of the window at <b>nyquist</b> frequency will be the value given (with linear interpolation of widths inbetween). <br />
				If two values are given these are the window widths at <b>0 Hz</b> and the <b>nyquist</b> frequency respectively (with linear interpolation of widths inbetween). No values switches smoothing off. <br />
				<b>units: none, float/list, default: 0</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Smoothing Amounts" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="smoothmode" get="1" set="1" type="int" size="1">
			<digest>
				Smoothing Mode
			</digest>
			<description>
				High-quality smoothing offers a higher quality result (especially on shorter signals), but is very CPU-intensive, so calculation times can be quite long, even impractically so. <br />
				The fast mode is significantly faster (as it computes in linear time) and sufficiently accurate for many purposes. Thus, this is the default mode for the <m>irplapprox~</m> and <m>irreference~</m> objects. <br />
				If you change this you can expect very long wait times! <br />
				<b>units: flag, default: 0, range: 0/1</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Smoothing Mode" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="writechan" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Write Channel
			</digest>
			<description>
				Sets the channel number for <o>buffer~</o> writing (1-4). If the specified channel does not exist the value is wrapped within the existing number of channels (so 3 will write to channel 1 of a two-channel <o>buffer~</o>, 4 to channel 2). <br />
				<b>units: int, default: 1, range: 1..4</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Write Channel" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		The <o>irreference~</o> object can be used either to estimate IRs using an arbitrary excitation signal (such as music), or to estimate the relative IR between two systems (such as between two different microphone inputs). The IR is derived from deconvolution of the recorded inputs. As an arbitrary signal is unlikely to be optimal for IR measurement, if only the amplitude response is required spectral smoothing of the two measurement signals before deconvolution may be applied. In this case the phase of the signals is dismissed and the smoothed spectra are set to minimum phase before deconolvution.
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="iralign~" />
		<seealso name="iraverage~" />
		<seealso name="irextract~" />
		<seealso name="irinvert~" />
		<seealso name="irmeasure~" />
		<seealso name="irnonlin~" />
		<seealso name="irphase~" />
		<seealso name="irplapprox~" />
		<seealso name="irstats~" />
		<seealso name="irsweeps~" />
		<seealso name="irtransaural~" />
		<seealso name="irtrimnorm~" />
		<seealso name="iruser~" />
		<seealso name="irvalue~" />
		<seealso name="bufconvolve~" />
		<seealso name="bufresample~" />
		<seealso name="bufreverse~" />
		<seealso name="morphfilter~" />
		<seealso name="multiconvolve~" />
		<seealso name="spectrumdraw~" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (signal)">
			<description>
				Audio Reference Input / Instructions In.
			</description>
		</entry>
		<entry name ="Inlet 2 (signal)">
			<description>
				Audio Measurement Inlets.
				The number of audio signal inputs for realtime processing is determined by the argument(s) to the object
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (signal)">
			<description>
				Left outlet: 0..1 or ms.
				Left outlet: Measurement Progress (0..1 or ms depending on the <m>absprogress</m> attribute)
			</description>
		</entry>
		<entry name ="Outlet 2 (bang)">
			<description>
				Right outlet: <m>bang</m>.
				Rightmost outlet: <m>bang</m> on completion of called process
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		The <o>irreference~</o> object can be used either to estimate IRs using an arbitrary excitation signal (such as music), or to estimate the relative IR between two systems (such as between two different microphone inputs). The IR is derived from deconvolution of the recorded inputs. As an arbitrary signal is unlikely to be optimal for IR measurement, if only the amplitude response is required spectral smoothing of the two measurement signals before deconvolution may be applied. In this case the phase of the signals is dismissed and the smoothed spectra are set to minimum phase before deconolvution.
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
impulse response, buffer, convolution, comparison, estimate, spectral, minimum phase.
			</description>
		</entry>
	</misc>

</c74object>