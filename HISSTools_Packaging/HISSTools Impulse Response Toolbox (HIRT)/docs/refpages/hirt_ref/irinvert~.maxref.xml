<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="irinvert~" module="hirt">

	<digest>
		IR Inversion
	</digest>

	<description>
		<o>irinvert~</o> performs inversion of an IR (or a multiple-in multiple-out system). There are various options for regularising or controlling the deconvolution process to produce useable results. <br />
		Because all processing is done using temporary memory it is safe for the output buffer(s) to be the same as the input buffer(s). <br />
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">Alex Harker</metadata>
		<metadata name="tag">HIRT</metadata>
		<metadata name="tag">HIRT Objects</metadata>
		<metadata name="tag">HIRT Impulse Response</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Instructions to <o>irinvert~</o>
			</digest>
			<description>
				<m>invert</m>, <m>mimo</m>, <m>mimoto</m>
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				<m>Bang</m> on completion of called process
			</digest>
			<description>
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="NONE" optional="0" type="none">
			<digest>
				No arguments for <o>irinvert~</o>
			</digest>
			<description>
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="invert">
			<arg name="out_buffer_name" optional="0" type="symbol" />
			<arg name="in_buffer_name" optional="0" type="symbol" />
			<arg name="time_multiplier" optional="1" type="float" />
			<digest>
				Invert the IR
			</digest>
			<description>
				Syntax: <b>invert <m>&lt;symbol: out_buffer_name&gt;</m> <m>&lt;symbol: in_buffer_name&gt;</m> <m>[&lt;float: time_multiplier&gt;]</m> </b><br />				<br />
				Invert the IR from the requested <o>buffer~</o> and place the result in the target <o>buffer~</o> <br />
				<br />
				<m>invert</m> defaults: [name] / [name] / 1. The output length is input <o>buffer~</o> length multiplied by <m>time_multiplier</m> rounded to the next power of two in samples. <br />
				<br />
				In the <o>HIRT</o>, all <b>time_multiplier</b>s are specified as <m>ints</m> or <m>floats</m> (of <b>1</b> or more) and effectively pad the inputs with zeros before deconvolution or other operations, multiplying the input length by the specified factor.
				This can be used to increase the size of the FFT used for processing, thus reducing time-aliasing, and increasing frequency resolution for deconvolution filters or phase manipulations.
				However, the size of the output will depend on the size of the FFT used, which is always rounded to the next higher power of two in samples.
				<br />
				<br />
			</description>
		</method>
		<method name="mimo">
			<arg name="num_sources" optional="0" type="int" />
			<arg name="time_multiplier" optional="1" type="float" />
			<arg name="out_buffer_names" optional="0" type="symbols" />
			<arg name="in_buffer_names" optional="0" type="symbols" />
			<digest>
				mimo in-place
			</digest>
			<description>
				Syntax: <b>mimo <m>&lt;int: num_sources&gt;</m> <m>[&lt;float: time_multiplier&gt;]</m> <m>&lt;symbols: out_buffer_names&gt;</m> <m>&lt;symbols: in_buffer_names&gt;</m> </b><br />				<br />
				Multi-channel systems can be inverted to create crosstalk cancellation and correction fllters. <br />
				The number of sources is the number of sources in the IR set. The number of receivers is automatically calculated from the number of IRs. Thus, IRs must be entered strictly in order (source-receiver - 1-1 1-2 .... 1-N 2-1 2-2 .... 2-N .... N-N). <br />
				<m>mimo</m> defaults: 1 / 1 / [name] / [name] / etc. The output length is input <o>buffer~</o> length multiplied by <m>time_multiplier</m> rounded to the next power of two in samples. <br />
				<br />
				In the <o>HIRT</o>, all <b>time_multiplier</b>s are specified as <m>ints</m> or <m>floats</m> (of <b>1</b> or more) and effectively pad the inputs with zeros before deconvolution or other operations, multiplying the input length by the specified factor.
				This can be used to increase the size of the FFT used for processing, thus reducing time-aliasing, and increasing frequency resolution for deconvolution filters or phase manipulations.
				However, the size of the output will depend on the size of the FFT used, which is always rounded to the next higher power of two in samples.
				<br />
				<br />
			</description>
		</method>
		<method name="mimoto">
			<arg name="num_sources" optional="0" type="int" />
			<arg name="time_multiplier" optional="1" type="float" />
			<arg name="out_buffer_names" optional="0" type="symbols" />
			<arg name="in_buffer_names" optional="0" type="symbols" />
			<digest>
				mimoto out-of-place
			</digest>
			<description>
				Syntax: <b>mimoto <m>&lt;int: num_sources&gt;</m> <m>[&lt;float: time_multiplier&gt;]</m> <m>&lt;symbols: out_buffer_names&gt;</m> <m>&lt;symbols: in_buffer_names&gt;</m> </b><br />				<br />
				Multi-channel systems can be inverted to create crosstalk cancellation and correction fllters. <br />
				The number of sources is the number of sources in the IR set. The number of receivers is automatically calculated from the number of IRs. Thus, IRs must be entered strictly in order (source-receiver - 1-1 1-2 .... 1-N 2-1 2-2 .... 2-N .... N-N). <br />
				<m>mimoto</m> defaults: 1 / 1 / [names] / [names] / etc. The output length is input <o>buffer~</o> length multiplied by <m>time_multiplier</m> rounded to the next power of two in samples. <br />
				<br />
				In the <o>HIRT</o>, all <b>time_multiplier</b>s are specified as <m>ints</m> or <m>floats</m> (of <b>1</b> or more) and effectively pad the inputs with zeros before deconvolution or other operations, multiplying the input length by the specified factor.
				This can be used to increase the size of the FFT used for processing, thus reducing time-aliasing, and increasing frequency resolution for deconvolution filters or phase manipulations.
				However, the size of the output will depend on the size of the FFT used, which is always rounded to the next higher power of two in samples.
				<br />
				<br />
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="deconvdelay" get="1" set="1" type="atom" size="1">
			<digest>
				Deconvolution Modelling Delay
			</digest>
			<description>
				Deconvolution can result in time-aliasing. In order to make sure that the resultant IR is correctly contained within the period of the FFT, it may be necessary to introduce a modelling delay (shifting the output of the deconvolution). <br />
				This delay can either be set in milliseconds or using the symbol 'center' which sets the delay to half of the FFT size. <br />
				This attribute is not available in the <o>irmeasure~</o> &amp; <o>irextract~</o> objects, as the timing is tightly controlled by the synchronous recording/playback process, making a modelling delay unnecessary. <br />
				<b>units: milliseconds or symbol</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Modelling Delay" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvfilter" get="1" set="1" type="atom_array" size="0">
			<digest>
				Deconvolution Filter Specification
			</digest>
			<description>
				Regardless of the deconvolution mode (<m>deconvmode</m>) it is necessary to set a specification for how to control the deconvolution over the frequency range. The <m>deconvfilter</m> specification sets a frequency curve to apply to the relevant mode. <br />
				You may either specify a static value in <b>dB</b>, or a <m>list</m> of <b>freq/dB</b> values to vary the specification with frequency. For <m>regularisation</m> this sets the constant value to add to the divisor. <br />
				For <m>clipping</m> it sets the minimum values allowed for the division. For <m>filter</m> it sets the shape of the filter. <br />
				Typically, for standard usage, very low or high frequencies are liable to blowup through overcorrection or numeric error. Thus higher values for <m>regularisation</m> and <m>clipping</m> are appropraite at low/high frequencies. <br />
				The <m>filter</m> mode works in the inverse, and lower values (less gain) are generally more appropriate for extremes of frequency. <br />
				Additionally you may specify the name of a <o>buffer~</o> as the filter specification in which case the power spectrum of the <o>buffer~</o> is used to determine the specification for <m>regularisation</m> and <m>clipping</m> modes, <br />
				and the <o>buffer~</o> is applied directly as a convolution filter in <m>filter</m> mode (ignoring the <m>deconvphase</m> attribute setting in this case). <br />
				This allows a high degree of control of the process for special applications or custom solutions. <br />
				<b>units: symbol &amp; list</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Specification" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvmode" get="1" set="1" type="int" size="1">
			<digest>
				Deconvolution Filter Mode
			</digest>
			<description>
				Deconvolution must be controlled so as to prevent filter blow-up or excessive time-aliasing. The control is equivalent to filtering the result of a staightforward complex division in the frequency domain (hence the term filter). The three modes are: <br />
				<b>0</b>, Regularisation: Regularise the division by adding a constant to the division <br />
				<b>1</b>, Clipping: Clip the denominator in the division <br />
				<b>2</b>, Specify the filter explicitly <br />
				<b>units: int, default: 0, range: 0..2</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Mode" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="deconvphase" get="1" set="1" type="atom" size="1">
			<digest>
				Deconvolution Filter Phase
			</digest>
			<description>
				The method by which deconvolution is controlled acts as a FIR filter on result of the 'true deconvolution'. This filter will produce time smearing of the result. This can result in pre or post ring in the resultant IR. <br />
				By controlling the phase of the implicit filter we can control this ring. <br />
				The default is <b>minimum</b> phase which post-rings only. The phase may either be specified as a float value between <b>0</b> and <b>1</b> (where <b>0</b> is <b>minimum</b> phase, <b>0.5</b> is <b>linear</b> phase and <b>1</b> is <b>maximum</b> phase), <br />
				or using any of the following symbols: <br />
				<b>min</b> / <b>minimum</b>: Minimum Phase <br />
				<b>lin</b> / <b>linear</b>: Linear Phase <br />
				<b>max</b> / <b>maximum</b>: Maximum Phase <br />
				<b>units: float or symbol, default: 0 / minimum, range: 0..1 or min/lin/max</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Phase" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="deconvrange" get="1" set="1" type="atom_array" size="0">
			<digest>
				Deconvolution Filter Range
			</digest>
			<description>
				When <m>deconvmode</m> is <m>clipping</m> the denominator of the divsion can be clipped to both minimum values (controlling peaks in the output) and also maximum values (controlling dips in the output). <br />
				The <m>deconvrange</m> attibute sets the maximum values in relation to the filter specification. Similarly to the deconvolution filter specification (<m>deconvfilter</m>),
				you may either specify a single value in <b>dB</b> or use a list of <b>freq/dB</b> pairs to vary the range with frequency. <br />
				<b>units: symbol &amp; list</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Deconvolution Filter Range" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="readchan" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Read Channel
			</digest>
			<description>
				Sets the channel number for <o>buffer~</o> reading (1-4). If the specified channel does not exist the value is wrapped within the existing number of channels (so 3 will read from channel 1 of a two-channel <o>buffer~</o>, 4 from channel 2). <br />
				<b>units: int, default: 1, range: 1..4</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Read Channel" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="resize" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Resize
			</digest>
			<description>
				If on, the <o>buffer~</o> will resize to the necessary size before write. Resizing erases all contents of the <o>buffer~</o>. <br />
				Otherwise, output will ONLY happen if there is enough room to write the entire output, leaving the latter contents of the <o>buffer~</o> and other <o>buffer~</o> channels unaffected. <br />
				<b>units: flag, default: 1, range: 0/1</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Resize" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="writechan" get="1" set="1" type="int" size="1">
			<digest>
				Buffer Write Channel
			</digest>
			<description>
				Sets the channel number for <o>buffer~</o> writing (1-4). If the specified channel does not exist the value is wrapped within the existing number of channels (so 3 will write to channel 1 of a two-channel <o>buffer~</o>, 4 to channel 2). <br />
				<b>units: int, default: 1, range: 1..4</b>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Buffer Write Channel" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		Further Reading: <br />
		<br />
		Fast Deconvolution: <br />
		<br />
		O. Kirkeby, P. Rubak, P. A. Nelson, and A. Farina, “Design of cross-talk cancellation networks by using fast deconvolution,” in Audio Engineering Society Convention 106, 5 1999 <br />
		Deconvolution Filter Phase: <br />
		<br />
		M. Bouchard, S. G. Norcross, and G. A. Soulodre, “Inverse filtering design using a minimal-phase target function from regularization,” in Audio Engineering Society Convention 121, 10 2006 <br />
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="iralign~" />
		<seealso name="iraverage~" />
		<seealso name="irextract~" />
		<seealso name="irmeasure~" />
		<seealso name="irnonlin~" />
		<seealso name="irphase~" />
		<seealso name="irplapprox~" />
		<seealso name="irreference~" />
		<seealso name="irstats~" />
		<seealso name="irsweeps~" />
		<seealso name="irtransaural~" />
		<seealso name="irtrimnorm~" />
		<seealso name="iruser~" />
		<seealso name="irvalue~" />
		<seealso name="bufconvolve~" />
		<seealso name="bufresample~" />
		<seealso name="bufreverse~" />
		<seealso name="morphfilter~" />
		<seealso name="multiconvolve~" />
		<seealso name="spectrumdraw~" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (messages)">
			<description>
				Instructions to <o>irinvert~</o>.
				<m>invert</m>, <m>mimo</m>, <m>mimoto</m>
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (bang)">
			<description>
				<m>Bang</m> on completion of called process.
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		Further Reading: <br />
		<br />
		Fast Deconvolution: <br />
		<br />
		O. Kirkeby, P. Rubak, P. A. Nelson, and A. Farina, “Design of cross-talk cancellation networks by using fast deconvolution,” in Audio Engineering Society Convention 106, 5 1999 <br />
		Deconvolution Filter Phase: <br />
		<br />
		M. Bouchard, S. G. Norcross, and G. A. Soulodre, “Inverse filtering design using a minimal-phase target function from regularization,” in Audio Engineering Society Convention 121, 10 2006 <br />
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
impulse response, buffer, convolution, mimo.
			</description>
		</entry>
	</misc>

</c74object>